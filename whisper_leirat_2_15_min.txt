Jó napot kívánok mindenkinek! Ezen az első előadáson általános áttekintő dolgokról lesz szó, amelyek kapcsolódnak a gépi tanulási módszerekhez. Általános áttekintő dolgokról lesz szó, amelyek kapcsolódnak a gépi tanulási módszerekhez. Tehát a mai órán ilyen nagyon általános dolgokkal foglalkozunk, amelyek minden gépi tanuló algoritmusra igazak, és majd a későbbi órákon fogunk belemenni egy-egy konkrét algoritmusban. Jó, tehát induljunk onnan, hogy próbáljuk meg egyáltalán megfogalmazni, hogy virul is szól ez az egész témakör, a gépi tanulás. Próbáljuk meg egyáltalán megfogalmazni, hogy virul is szól ez az egész témakör, a gépi tanulás. A nagyon általános megfogalmazás az az lenne, hogy a célunk olyan programok létrehozása, amelyek a működésük során gyűjtött tapasztalatok segítségével képesek javítani a saját hatékonyságukon. Nyilván ez egy nagyon általános megfogalmazás, tehát ez még nem elég konkrét, de itt pont az volt a cél ennél a megfogalmazásnál, hogy lehetőleg mindent lefegyünk. Tehát a lényeg az lesz, hogy olyan algoritmusokat szeretnénk csinálni, amelyek valahogy működésünk során tapasztalatokat gyűjtenek, és ennek segítségével egyre jobban fognak működni. Természetesen ezt konkrétizálnunk kell, hogy mik lennének ezek a tapasztalatok. Mit értünk azon, hogy tapasztalat? Mit értünk azon, hogy javul? Hogyan mérjük, hogy a hatékonyságot? Mi az a hatékonyság? Hogyan fogjuk javítani? Szóval egy csomó mindent definiálnunk kell, de itt az első megfogalmazásnál az volt a cél, hogy minél általánosabbak legyünk. Tehát ezt most fokozatosan szűkítjük, lekonkretizáljuk a dolgokat. Ennek az lesz az ára, hogy egyre szűkülni is fog a lefedett dolgoknak a tere. Jó, tehát a lényeg az az lesz, hogy tanuló algoritmusokat szeretnénk készíteni. Ezen olyan algoritmusokat értünk, amelyek képesek tanuló algoritmusokat szeretnénk készíteni, ezen olyan algoritmusokat értünk, amelyek képesek szabályosságok összefüggésére. Tehát most már annyit konkrétizáltunk, hogy a tanuláshoz tanító példákat fogunk használni, tehát példákból kell majd kinyerni az összefüggősöket. Ez még mindig közös, hogy mit értünk azon, hogy szabályosságok összefüggések. Tehát mindjárt ezt is pontosítjuk. Tehát mindjárt ezt is pontosítjuk, de előbb lenne két megjegyzésem. Az egyik az az, hogy fontos dolg lesz majd az, hogy, nem az lesz nekünk a lényeg, hogy a konkrét tanuló példákat megtanuljuk, és azokra jól működjön a rendszer. Nyilván ez is fontos lesz, de a lényeg az az lesz majd, hogy általánosítani tudjunk, amin azt értem, hogy a tanulás során nem látott példákra is szeretnénk, ha remélhetőleg jól működne a rendszer. Ezt szokták így is mondani, hogy induktív legyen a tanulás, tehát hogy a tudás az. Ez nyilván az, hogy a tanuló példákból tanulni tudjunk, ahhoz föléből. Föl kell azt tenni, hogy a tanuló példák nem félrevezetőek, tehát jól reprezentálják a tanulandó összefüggést. Hát ezt mindig föl fogjuk tenni, különben nem tudnánk használni ezeket a módszereket. A második megjegyzésünk az az, hogy a tanulásnak az eredménye mindig egy hipotézis lesz, tehát a rendszer az a továbbiakban, illetve ideírtam még ilyen apróságnak, hogy ez a hipotézis persze tovább, ahogy újabb, és újabb példák érkeznek, ezt mindig tovább tudjuk finomítani, és tovább tudjuk javítani. Itt alapból mindig talál valamilyen összefüggéseket és szabályokat, de ugye ezt sose lehetünk ebben biztosok, hogy ezek tökéletesen működnek, ezek az összefüggések. Nyilván tanító példákon látjuk, hogy jól működnek-e, de az, hogy a nem látott esetekben hogyan működnek, hogy a nem látott esetekről hogyan általánosítanak, arra sose lesz garanciánk. Tehát ezért is szoktunk szoktunk precízebben úgy fogalmazni, hogy hipotézist állítunk föl, tehát hogy nem garantáljuk, hogy megtanultuk, amit meg kell tanulni, hanem van egy hipotézisünk arra, vagy az algoritmusnak lesz egy hipotézis arra a dologra, amit meg kellett tanulnia, arra a dologra, amit meg kellett tanulnia, de erre nincs garancia, hogy ez jól fog működni. Jó, erről rengeteget fogunk beszélni. Tehát azt a felállást fogjuk használni, hogy lesz egy tanítási fázis, tehát amikor tanító példákat mutatunk a rendszernek, kialakít valamilyen modellt majd, és aztán egy tesztelési fázisból megnézzük tesztadatokon, hogy hogy működik. Tehát mi ezt az egyszerű sémát fogjuk itt feltételezni végig, de elvileg meg lehet azt csinálni, hogy mindig új példák jönnek, és akkor mindig lehet tovább javítani a modellt. Tehát ezt a legtöbb algoritmusnál triviális módon, vagy nagyon egyszerű módon meg lehet csinálni, hogy folyamatosan új példák, jöjjenek és folyamatosan javítson a működésén. De mi most itt az egyszerűség kedvéért mindig ezt a felállást fogjuk emlegetni, hogy van egy tanulási rész, egy tanulási fázis, és utána egy tesztelési fázis, amikor megnézzük, hogy hogyan működik a rendszerünk. Ha egy kicsit próbáljuk a feladatokat konkretizálni, a leggyakoribb feladattípus, amit a gépi tanulásnál emelgetni szoktak, az a felületes, a felügyelt tanulás, angolul supervised learning. Ez magyarul azt jelenti, hogy a tanító példákozó helyes válasz is adott. Ezen a feladattípuson belül is a leggyakoribb feladat az úgynevezett osztályozási feladat. Mindjárt szó lesz a másik két esetről is, de azok is nagyon hasonlóak. Példán keresztül próbálom megvilágítani, hogy ez hogy működik. Mondjuk a karakter felismerése szerintem egy nagyon kézzelfogható és érthető feladat. A kézzelfogható és érthető feladat kapunk kis képeket, amelyek kis képeken betűk vannak. Az inputok azok képek lesznek, és a rendszernek az a feladata, hogy meggondja, hogy a képen milyen betű látható. És a rendszernek az a feladata, hogy meggondja, hogy a képen milyen betű látható. Most ideírtam egy példának a 16x16 pixelez, de nyilván ez akárhány pixel lehet. Most ezeket a bemenő képet, ami nyilván digitális és ebből pixelek formájában adott, ezeket inputnak, pixeleket input jellemzőknek fogjuk hívni. És itt pedig az output, ugye az egy betű lesz. Tehát a képeket osztályokba kell sorolnunk, minden betűhöz tartozni fog egy osztály. Tehát az lesz egy A betűk osztálya, B betűk osztálya, és így tovább. Jó, és akkor az is látjuk, hogyha az ember, hogyha ezt a felügyel találási feladatot, ugye nyilván majd valahogy, formalizálnunk kell matematikailag. Hát szerintem elég nyilvánvalóan látszik rajta, hogy ez egy függvény. Tehát valamiért bemegy valami, meg kijön valami, tehát a képek teréből le kell képeznünk a betűk terébe, tehát egy függvényt kell megtanulnunk. Tehát nyilván függvényen fogjuk ezt a dolgot modellezni. És a fél év során szinte kizárólag ilyen jellegű feladatokról lesz szó. Tehát ez a legfontosabb feladattípus a gépjétanulásban, és a kurzusban erre fogunk látni majd vagy tízféle megoldást. Tehát azt fogjuk majd látni, hogy ugyanez a feladat, azt nagyon különböző féleképpen lehet külön közelíteni. Jó, azért itt most az elején említésen szintén felsorolok néhány más feladattípust is. A felügyelt tanulásnak van egy ilyen párja, hogy felügyelet nélküli tanulás. Hát mint a neve mutatja, ez azt jelenti, hogy nincsen külső támogatás, nincsenek osztálycímkék. Tehát csak adatpontok. Ugye azért valahogy azt meg lehet próbálni mérni, hogy mennyire hasonlóak vagy nem hasonlóak a képek. Tehát nyilván azt nem tudom eldönteni, hogy A betű vagy B betű van rajta, mert ugye nincs rá példám, nem tudom, mi az, hogy a rendszer nem tudja, mi az, hogy A betű meg B betű, de azt el tudja dönteni, hogy ez a kép valamilyen jelentően behasonlít a másikra. És akkor ilyen kupacokban, ilyen automatikusan kialakított osztályokban tudja sorolni a példákat. Most ezt a feladatot hívják klaszterezésnek. Tehát ugye itt az lenne, azért is van dörtbetűvel szedve, az lenne a lényeg, hogy az osztályokat is automatikusan kell feltételezni a rendszernek. Az osztályokat is automatikusan kell feltételezni a rendszernek. Nyilván ehhez meg kell neki mondanom, hogy mit értek azon, hogy két kép hasonló. Tehát az egy létfontosságú elem itt, hogy mi lesz a hasonlósági mérték. De megmondjuk a gépnek, hogy mit értek azon, hogy két, mondjuk jelen példában két kép hasonló, akkor ő már az alapján be tud, ki tud alakítani csoportokat a hasonlóság alapján. Jó, tehát valami ilyesmi lesz a klaszterezési feladat. Erre egy darab példát fogok mutatni, a legegyszerűbb, legközismertebb algoritmust meg fogom mutatni a klaszterezésre. Igazából azért, mert nekünk ez majd ilyen segédeszközként fog kelleni egy másik algoritmushoz. Tehát ezt a legfontosabb ilyen klaszterező algoritmust meg fogjuk nézni. Jó, aztán felsoroltam ide még két másik feladattipust. Hát, mint látják, a felsorolás úgy ér véget, hogy egyéb speciális feladatok, tehát nem akartam itt semmilyen értelmebe kimerítő lenni. Biztos elő lehetne még bányászni sokféle egyéb kategóriát. Én két ilyen egyéb esetet írtam föl ide. Az egyik eset az lenne, hogy mi van, hogyha időbeli sorozatokat kell modellezni. Megvan a szövege eleje, mi lehet a következő szó. Itt van három szó, mi lehet a negyedik szó. Mondjuk egy magyar nyelvű, vagy egy angol nyelvű szövegbe. Ilyen lehet a beszédfelismerés. Ugye az szinte ugyanaz, mint az írott szöveg, csak hang az input. Ilyen lehet ugye a tőzsdei folyamatok modellezése. Tehát tegnap meg tegnap előtt ennyi volt az árfolyam, mi várható ma. Nyilván érzi az ember, hogy az a lényeges különbség az előző példához képest, hogy itt az egymás után érkező példák, azok függenek egymástól. Tehát az előző példákból tudom megmondani, hogy mi lesz a következő példa. Még mondjuk egy karakterfelismerési feladatnál általában azt tesszük fel, hogy függetlenek az egymás után érkező képek. Tehát az, hogy mi van a következő képen, az nem független, hogy mi volt az előző képen. Tehát ez lenne itt a lényeges különbség, hogy ebben az esetben viszont a korábbi képekben fontos információ rejlik. Tehát ez speciális modellek ellenek. Erre nem lesz. Egyébként az alkalmas az a megközelítés, amit mi itt használunk. De ilyen jelenlegű feladatok, így nem fogunk eljutni. Tehát egy másik különleges kategória, amit ide példának hoztam, az a megerősítéses tanulás, angolul reinforcement learning. Tanulás, angolul reinforcement learning. Ez a gépi tanuláson belül egy különálló irányzat, saját módszereivel, saját kutatóival, ami valamilyen értelme tanulás, de nem olyan tanulás, mint amiről az előbb beszéltünk, hogy egy eszélyfügg, mint kell. Megtanulni, megtanulni. A reinforcement learning-et úgy tudom talán legjobban leírni, hogy valami szokták őket agentnek is írni, próbálunk kreálni, próbálunk kreálni, amelyek, vagy akár egy kis robotra is tudnak, és gondolatnak nyugodtan, amelyik interakció, berakjuk valamilyen környezetbe, ő interakcióban van a környezetével, és tapasztalatokat gyűjt. A lényeges különbség az a felügyeltenüláshoz, ahhoz képest, hogy az egyes tapasztalatokhoz nem mindig van tanító címke, illetve nem is az a cél, hogy az egyes inputok, egyes akciókra jól reagáljon, hanem egy hosszú távú célt teszünk föl. Hát most ennél a kis robotnál lehet arra gondolni, hogy minél tovább életben maradjon. Tehát nyilván neki megy a falnak, tehát ilyen dolgok történnek vele, hogy neki megy a falnak, vagy leesik az asztalra, vagy nem tudom, ezek az apró élmények, amelyek érik, de nem az a fő cél itt, hogy ezekre az egyes eseményekre jól reagáljon, hanem hogy hosszú távon jól működjön, tehát például jelen esetben minél tovább életben maradjon. Úgyhogy látjuk, hogy, vagy amit példának itt szoktam hozni, mondjuk egy sakjátszma, egy sakkozógépet akarok tanítani, egy sakjátszma, egy sakkozógépet akarok tanítani, ott ugye nem feltétlenül, ott ugye lépés, sakkparti lépésekből állnak, de ott ugye ott is az a cél, hogy megnyerjem a partit, az egyes. Nyilván valamennyire ez egyes lépésekről is meg lehet mondani, hogy ez jó lépés volt, vagy rossz lépés volt, de azért van olyan mondjuk, hogy tisztáldozat azért, tehát úgy rövid távon vesztek valamit azért, hogy később nyerjek, tehát úgy rövid távon vesztek valamit azért, hogy később nyerjek, tehát nem feltétlenül lehet megmondani minden egyes lépésre, hogy ez jó vagy rossz volt, hanem az egész meccsnek, az egész partinak a folyamatát kell nézni. Jó, tehát remélem ezzel érzékeltettem, hogy miben tér el ez a reinforcement learning, de erről tényleg itt most csak érdekességképpen meséltem, tehát nem fogunk ezzel foglalkozni, nem fogunk ezzel foglalkozni külön terület a gépi tanuláson belül is külön módszerekkel. Jó, na ennyit általánosságban, és akkor még egyszer mondom ezzel a függvény tanulási, vagy felügyelt tanulási, úgyhogy térjünk erre rá egy kicsit és pontosítsuk a dolgokat. Ugye maga a függvény, amit meg akarunk tanulni, annak lesz egy inputja, az előző példában a karakterfelismerési példában az inputom az egy kép volt. Általánosabban azt szoktuk mondani, hogy valamiféle mérési adatokból álló vektor lesz az input, tehát általában nem egy adaton van, hanem több adaton megy be, ugye az előző példában egy 16x16 pixel megy be. Ezeket az adatokat jellemződik, és jellemző vektornak szoktuk, tehát nyilván az egyes adatkomponenseket jellemzőnek hívjuk, a belőlük alkotott vektort pedig jellemző vektornak. Szoktam angolul is említeni, hogy feature vector, illetve vannak itt ilyen bizonyos területek, ahol attributumnak is szokták ezt hívni, tehát ha azt mondom, hogy jellemző vagy feature vagy attributum, az ugyanaz, ugyanúgy gondoljanak vele. Jó, tehát ez lesz az inputom, a függvény outputja pedig alapvetően kétfajta lehet, a leggyakoribb esetben osztály címként jön ki, tehát ez a tipikus példa, mondjuk az előbb a karakterfelismerésnél, ugye az A-tól az E-ig kb. ötven darab betű van, tehát ötven darab osztályom lesz ebben az esetben. És ugye azt várom a rendszertől, hogy amikor mutatok neki egy képet, akkor egy konkrét osztály címkét mondja meg, hogy ez a cím. Jó, egy másik típusú feladat az, amikor valós értékek jönnek ki, ezt regressziós feladatnak hívjuk, tehát későbbi diákon lesz erre is példa. Jó, tehát ez maga, még egyszer, ez maga egy konkrét feladat esetén ez a függvény, amit meg akarunk tanulni.